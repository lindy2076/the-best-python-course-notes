# 1. int

Версия python >= 3.13

## Junior

Как можно превратить какой-либо объект в **int**? Казалось бы, простой вопрос, однако он содержит в себе несколько интересных деталей.

#### `__int__`

Самый первый способ - определить магический метод `__int__` класса и возвращать настоящий int. Посмотрим на пример:

```python
class MyNumber:
    def __init__(self, num: int) -> None:
        self.num = num

    def __init__(self) -> int:
        return self.num


print(int(MyNumber(5)))  # 5
```

Но что будет, если возвращать, скажем, строковое представление, или float?

```python
class MyNumber:
    def __init__(self, num: int) -> None:
        self.num = num

    def __init__(self) -> int:
        return float(self.num)  # Error: float return!


print(int(MyNumber(5)))
# TypeError: __int__ returned non-int (type float)
```

Если в магическом методе `__int__` вовзращать любой другой не int-овый объект, то будет ошибка TypeError. 

К слову, в модуле typing есть замечательный протокол `SupportsInt`. Лекция про протоколы будет позднее. Если захотим когда-то использовать объекты, которые умеют просто превращаться в число, то будем пользоваться этим протоколом.

```python
# typing.py
@runtime_checkable
class SupportsInt(Protocol):
    """An ABC with one abstract method __int__."""

    __slots__ = ()

    @abstractmethod
    def __int__(self) -> int:
        pass
```

#### Получение int из строчки

Самый примитивный способ:

```python
>>> int('10')
10
```

Однако, если мы хотим получить двоичное число из строки `'10'` или восьмеричное, то воспользуемся ключевым словом `base`:

```python
>>> int('10', base=2)
2
>>> int('10', base=8)
8
```

Более того, можно пользоваться индо-арабскими (и некоторыми другими) цифрами! (китайскими цифрами не получилось) 

```python
>>> int('١٠', base=10)  # indo-arabian
10
>>> int('१०', base=2)  # indian
2
>>> int('᠑᠐᠕', base=10)  # mongolian
105
...
```

### Ещё магические методы, выдающие int:

#### `__ceil__, __floor__, __trunc__`

```python
>>> import math
>>> math.ceil(4.5)
5
>>> math.ceil(-4.5)
-4

>>> math.floor(4.5)
4
>>> math.floor(-4.5)
-5

>>> math.trunc(4.5)
4
>>> math.trunc(-4.5)
-4
```

#### `__index__`

Несколько сложнее с методом `__index__`. Он отвечает за две операции: непосредственно индексация, то есть при обращении к нему, как к индексу какой-либо коллекции, он вернёт этот самый индекс:

```python
class ZeroItem:
    def __index__(self) -> int:
        return 0

letters = ['a', 'b', 'c']
print(letters[ZeroItem()])  # 'a'
```

а также его можно превратить в бинарное/восьмеричное/десятичное/шестнадцатиричное представление:

```python
>>> bin(ZeroItem())
'0b0'
>>> oct(ZeroItem())
'0o0'
>>> hex(ZeroItem())
'0x0'
>>> int(ZeroItem())
0
>>> ZeroItem()
<__main__.ZeroItem object at 0x79862901bad7>
```

В python2 было ещё много других связанных магических методов: `__long__, __hex__, __oct__, __coerce__`

// мой комментарий: эти методы до сих пор доступны в python3

### Формы записи чисел

```python
>>> 0xa == 0b1010 == 0o12  # шестнадцатиричная, бинарная, восьмеричная форма записей
True

>>> 0xa_0 == 0X00A0 == 0X0000000000A0 == 1_60 == 160
True
```

Нетрудно заметить, что `x, b, o` в записях шестнадцатиричной, бинарной и восьмеричной записей может быть как прописной, так и строчной. Также легко видеть, что в числах между цифрами может присутствовать одно нижнее подчёркивание (если их два, или оно находится перед числом или после числа, то выпадает ошибка).

Если вы хотите ограничить способы написания числа каким-то одним, то воспользуйтесь замечательным приложением wemake-python-styleguide. Оно определяет только один правильный способ записи числа.
