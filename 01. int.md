# 1. int

Версия python >= 3.13.

В репе в папке homeworks лежит mdшка с полезными ссылками, без них будет тяжело разобраться с уровнями выше джуна.

## Junior

Как можно превратить какой-либо объект в **int**? Казалось бы, простой вопрос, однако он содержит в себе несколько интересных деталей.

#### `__int__`

Самый первый способ - определить магический метод `__int__` класса и возвращать настоящий int. Посмотрим на пример:

```python
class MyNumber:
    def __init__(self, num: int) -> None:
        self.num = num

    def __init__(self) -> int:
        return self.num


print(int(MyNumber(5)))  # 5
```

Но что будет, если возвращать, скажем, строковое представление, или float?

```python
class MyNumber:
    def __init__(self, num: int) -> None:
        self.num = num

    def __init__(self) -> int:
        return float(self.num)  # Error: float return!


print(int(MyNumber(5)))
# TypeError: __int__ returned non-int (type float)
```

Если в магическом методе `__int__` вовзращать любой другой не int-овый объект, то будет ошибка TypeError. 

К слову, в модуле typing есть замечательный протокол `SupportsInt`. Лекция про протоколы будет позднее. Если захотим когда-то использовать объекты, которые умеют просто превращаться в число, то будем пользоваться этим протоколом.

```python
# typing.py
@runtime_checkable
class SupportsInt(Protocol):
    """An ABC with one abstract method __int__."""

    __slots__ = ()

    @abstractmethod
    def __int__(self) -> int:
        pass
```

#### Получение int из строчки

Самый примитивный способ:

```python
>>> int('10')
10
```

Однако, если мы хотим получить двоичное число из строки `'10'` или восьмеричное, то воспользуемся ключевым словом `base`:

```python
>>> int('10', base=2)
2
>>> int('10', base=8)
8
```

Более того, можно пользоваться индо-арабскими (и некоторыми другими) цифрами! (китайскими цифрами не получилось) 

```python
>>> int('١٠', base=10)  # indo-arabian
10
>>> int('१०', base=2)  # indian
2
>>> int('᠑᠐᠕', base=10)  # mongolian
105
...
```

### Ещё магические методы, выдающие int:

#### `__ceil__, __floor__, __trunc__`

```python
>>> import math
>>> math.ceil(4.5)
5
>>> math.ceil(-4.5)
-4

>>> math.floor(4.5)
4
>>> math.floor(-4.5)
-5

>>> math.trunc(4.5)
4
>>> math.trunc(-4.5)
-4
```

#### `__index__`

Несколько сложнее с методом `__index__`. Он отвечает за две операции: непосредственно индексация, то есть при обращении к нему, как к индексу какой-либо коллекции, он вернёт этот самый индекс:

```python
class ZeroItem:
    def __index__(self) -> int:
        return 0

letters = ['a', 'b', 'c']
print(letters[ZeroItem()])  # 'a'
```

а также его можно превратить в бинарное/восьмеричное/десятичное/шестнадцатиричное представление:

```python
>>> bin(ZeroItem())
'0b0'
>>> oct(ZeroItem())
'0o0'
>>> hex(ZeroItem())
'0x0'
>>> int(ZeroItem())
0
>>> ZeroItem()
<__main__.ZeroItem object at 0x79862901bad7>
```

В python2 было ещё много других связанных магических методов: `__long__, __hex__, __oct__, __coerce__`

// мой комментарий: эти методы до сих пор доступны в python3

### Формы записи чисел

```python
>>> 0xa == 0b1010 == 0o12  # шестнадцатиричная, бинарная, восьмеричная форма записей
True

>>> 0xa_0 == 0X00A0 == 0X0000000000A0 == 1_60 == 160
True
```

Нетрудно заметить, что `x, b, o` в записях шестнадцатиричной, бинарной и восьмеричной записей может быть как прописной, так и строчной. Также легко видеть, что в числах между цифрами может присутствовать одно нижнее подчёркивание (если их два, или оно находится перед числом или после числа, то выпадает ошибка).

Если вы хотите ограничить способы написания числа каким-то одним, то воспользуйтесь замечательным приложением wemake-python-styleguide. Оно определяет только один правильный способ записи числа.

## Middle

Мы рассмотрели базовые методы над числами, посмотрим теперь, какие числа бывают в питоне.

Вообще бывают натуральные, целые, рациональные, вещественные и комплексные числа. Так же и в питоне! В нём есть следующие базовые абстрактные классы: `Number, Complex, Real, Rational, Integer` (наследуются в такой последовательности). Они лежат в `numbers.py` стандартной библиотеки [(тык)](https://github.com/python/cpython/blob/main/Lib/numbers.py).

Все числа наследуются от базового класса Number, у которого есть слоты и хеш. Разберёмся позднее, для чего они нужны.

```python
...
from abc import ABCMeta, abstractmethod

__all__ = ["Number", "Complex", "Real", "Rational", "Integral"]

class Number(metaclass=ABCMeta):
    """All numbers inherit from this class.

    If you just want to check if an argument x is a number, without
    caring what kind, use isinstance(x, Number).
    """
    __slots__ = ()

    # Concrete numeric types must provide their own hash implementation
    __hash__ = None
...
```

Эти абстрактные классы описывают абстрактные методы и пропертис, а также реализуют некоторые методы.

Если вы хотите написать свою реализацию чисел, то можете просто отнаследоваться от этих абстрактных классов. А если реализация написана на сях, то можно зарегать методом register `Complex.register(complex)`.

Посмотрим на некоторые нюансы:

```python
>>> from numbers import Integral

>>> issubclass(int, Integral)
True

>>> int.__bases__
(<class 'object'>,)  # why? магия абстрактных классов!
```

Более подробно про `numbers.py` в [документации](https://docs.python.org/3/library/numbers.html). А [pep-3141](https://peps.python.org/pep-3141) расскажет, зачем этот модуль вообще нужен. В двух словах: для создания своих "числовых" типов, и для стандартизации поведения чисел.

#### Проблемы

Не стоит использовать классы из numbers.py в качестве аннотаций. Не все объекты, описанные там, соответствуют сишной реализации.

Decimal не зарегестрирован ни одним абстрактным типом. К слову, у него есть две реализации - на питоне и сях.

```python
>>> Decimal.register()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: type object 'decimal.Decimal' has no attribute 'register'
```

// мой комментарий: `issubclass(Decimal, Number)` даёт `True`, однако для `Complex` уже `False`.

Вот некоторые примеры проблем:

```python
>>> from numbers import Complex
>>> isinstance(1, Complex)
True                          # значит 1 комплексна! 

>>> Complex.__complex__       # у комплексных чисел есть такой метод
<function Complex.__complex__ at 0x798629082660>

>>> (1).__complex__()         # вызываем...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'int' object has no attribute '__complex__'
```
