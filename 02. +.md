# 2. +

## Junior

### `__add__, __radd__`
Сложение на уровне python работает очень просто. Есть два магических метода: `__add__` и `__radd__`. Они различаются тем, что срабатывают в зависимости от положения объекта в сложении (всё-таки сложение - бинарная операция).

Посмотрим на пример:

```python
class Empty: ...

class A:
    def __add__(self, other):
        return 'A'
    
class B:
    def __radd__(self, other):
        return 'B'


print(A() + Empty())  # 'A'
print(Empty() + B())  # 'B'

print(B() + A())      # TypeError: unsupported operand
print(Empty() + A())  # TypeError: unsupported operand 
print(B() + Empty())  # TypeError: unsupported operand
```

#### NotImplemented
Важный синглтон для изменения некоторых магических методов. Если мы переопределим методы из предыдущего примера таким образом:

```python
class A:
    def __add__(self, other):
        if not isinstance(other, A):
            return NotImplemented
        return 'A'
    
class B:
    def __radd__(self, other):
        if isinstance(other, A):
            return 'AB'
        return 'B'


print(A() + A())  # 'A'
print(A() + B())  # 'AB' ! 
```

Произошёл интересный случай. Из A возвратился NotImplemented, но из B возвратился AB. Теперь переопределим `__radd__` у B:

```python
class A:
    def __add__(self, other):
        if not isinstance(other, A):
            return NotImplemented
        return 'A'
    
class B:
    def __radd__(self, other):
        if isinstance(other, A):
            return NotImplemented
        return 'B'


print(A() + A())  # 'A'
print(A() + B())  # TypeError
```

Ещё один корнер-кейс. Если теперь отнаследовать B от A, то сработает метод `__radd__` наследника:

```python
class A:
    def __add__(self, other):
        return 'A'

class B(A):
    def __radd__(self, other):
        return 'B'


print(A() + B())  # 'B'
```

### `__iadd__` (+=)


```python
from dataclasses import dataclass
from typing import Self

@dataclass
class Number:
    number: int

    def __iadd__(self, other: object) -> Self:
        return self.__class__(self.number + other)


five = Number(5)
five += 20
print(five)  # Number(number=25)
```

Если переименовать метод `__iadd__` в обычный `__add__`, то в этом случае ничего не поменяется - питон просто будет использовать `__add__` для `+=`. Однако, в некоторых случаях разница довольно ощутима. Например, для листа `+=` работает как `.extend`, в отличие от `+`:

```python
>>> numbers = [1, 2, 3]
>>> id(numbers)
136230017816512

>>> numbers += [4, 5]
>>> id(numbers)
136230017816512  # id тот же


>>> numbers2 = [1, 2, 3]
>>> id(numbers2)
136230017816576
>>> numbers2 = numbers2 + [4, 5]
>>> id(numbers2)
136230017815232  # ссылаемся на другой объект
```

### Приоритет операций

Многие видели [таблицу](https://docs.python.org/3/reference/expressions.html#operator-precedence) приоритета операций. Однако почему она работает именно так, посмотрим на уровне middle.

### Типизация сложения

Чтобы правильно типизировать код, можно использовать некоторые готовые компоненты. В случае сложения есть два протокола внутри библиотеки typeshed:

```python
# python/typeshed/blob/main/stdlib/_typeshed/__init__.pyi#L108

class SupportsAdd(Protocol[_T_contra, _T_co]):
    def __add__(self, x: _T_contra, /) -> _T_co: ...

class SupportsRAdd(Protocol[_T_contra, _T_co]):
    def __radd__(self, x: _T_contra, /) -> _T_co: ...
```

## Middle

Чтобы начать знакомство со сложением на уровне исходного кода, нам нужно познакомиться с тем, как питон преобразовывает сложение в абстрактное синтаксическое дерево (AST).

Для работы бинарных операторов есть специальный класс `BinOp`, наследуемый от `expr`:

```python
# python/typeshed/blob/main/stdlib/_ast.pyi#L238

class BinOp(expr):
    __match_args__ = ("left", "op", "right")
    left: expr
    op: operator
    right: expr


class operator(AST): ...
class Add(operator): ... # и множество других
```

Если мы напишем выражение 1 + 2 + 3, то получим следующую структуру:

```python
>>> import ast
>>> print(ast.dump(ast.parse('1+2+3'), indent=2))
Module(
  body=[
    Expr(
      value=BinOp(
        left=BinOp(
          left=Constant(value=1),
          op=Add(),
          right=Constant(value=2)),
        op=Add(),
        right=Constant(value=3)))],
  type_ignores=[])


# чуть более схематично:
                     |-right:   3
                     |-op:      Add
Module-Expr-BinOp----|
                     |                |-right:     2
                     |-left:    BinOp-|-op:       Add
                                      |-left:      1
```

Видим модуль, содержащий одно выражение, которое состоит из бинарной операции, где левый член - ещё одна бинарная операция сложения 1 и 2, а правый - 3

`BinOp` довольно важная часть питона, например `complex` представляется бинарной операцией.

```python
>>> complex(1)
(1+0j)

>>> print(ast.dump(ast.parse('1+0j'), indent=2))
Module(
  body=[
    Expr(
      value=BinOp(
        left=Constant(value=1),
        op=Add(),
        right=Constant(value=0j)))],
  type_ignores=[])
```

В [Lib/ast.py](https://github.com/python/cpython/blob/main/Lib/ast.py#L58) есть специальный корнер кейс для получения комплексного числа:

```python
# Lib/ast.py

def literal_eval(node_or_string):
    # ...
        elif isinstance(node, BinOp) and isinstance(node.op, (Add, Sub)):
            left = _convert_signed_num(node.left)
            right = _convert_num(node.right)
            if isinstance(left, (int, float)) and isinstance(right, complex):
                if isinstance(node.op, Add):
                    return left + right
                else:
                    return left - right

```

### порядок операций

Тот порядок, упомянутый в джуновском разделе, можно увидеть прямиком в [грамматике](https://github.com/python/cpython/blob/main/Grammar/python.gram#L773):

```python
# Grammar/python.gram#L773

bitwise_or[expr_ty]:
    | a=bitwise_or '|' b=bitwise_xor { _PyAST_BinOp(a, BitOr, b, EXTRA) }
    | bitwise_xor

bitwise_xor[expr_ty]:
    | a=bitwise_xor '^' b=bitwise_and { _PyAST_BinOp(a, BitXor, b, EXTRA) }
    | bitwise_and

bitwise_and[expr_ty]:
    | a=bitwise_and '&' b=shift_expr { _PyAST_BinOp(a, BitAnd, b, EXTRA) }
    | shift_expr

shift_expr[expr_ty]:
    | a=shift_expr '<<' b=sum { _PyAST_BinOp(a, LShift, b, EXTRA) }
    | a=shift_expr '>>' b=sum { _PyAST_BinOp(a, RShift, b, EXTRA) }
    | invalid_arithmetic
    | sum

sum[expr_ty]:
    | a=sum '+' b=term { _PyAST_BinOp(a, Add, b, EXTRA) }
    | a=sum '-' b=term { _PyAST_BinOp(a, Sub, b, EXTRA) }
    | term

term[expr_ty]:
    | a=term '*' b=factor { _PyAST_BinOp(a, Mult, b, EXTRA) }
    | a=term '/' b=factor { _PyAST_BinOp(a, Div, b, EXTRA) }
    | a=term '//' b=factor { _PyAST_BinOp(a, FloorDiv, b, EXTRA) }
    | a=term '%' b=factor { _PyAST_BinOp(a, Mod, b, EXTRA) }
    | a=term '@' b=factor { CHECK_VERSION(expr_ty, 5, "The '@' operator is", _PyAST_BinOp(a, MatMult, b, EXTRA)) }
    | invalid_factor
    | factor

factor[expr_ty] (memo):
    | '+' a=factor { _PyAST_UnaryOp(UAdd, a, EXTRA) }
    | '-' a=factor { _PyAST_UnaryOp(USub, a, EXTRA) }
    | '~' a=factor { _PyAST_UnaryOp(Invert, a, EXTRA) }
    | power

power[expr_ty]:
    | a=await_primary '**' b=factor { _PyAST_BinOp(a, Pow, b, EXTRA) }
    | await_primary

```

Порядок идёт сверху вниз, т.к. питоновский парсер для построения AST читает этот файл таким образом.

Если выражение сматчилось, то выдаём BiOpn с некоторым контекстом.

Для развития навыка чтения грамматик есть отличные тренажёры, ссылки на которые есть в списке дополнительных материалов.

### `__iadd__` атомарна?

Несмотря на то, что `+=` записывается в виде одной операции, атомарной он всё же не является.

Вот очень простой вопрос: дан кортеж из одного элемента. В нём лежит пустой лист. Экстендим лист операцией `+=` через индекс кортежа. Этого не может произойти, т.к. элементы кортежа нельзя менять переприсваиванием, их можно только мутировать. Справедливо выпадет ошибка. Но при этом сам кортеж изменится:

```python
>>> x = ([],)
>>> x[0] += [1]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> x
([1],)
```

Почему так происходит? Потому что мы можем представить эту операцию в виде двух независимых операций:
```python
result = x[0].__iadd__([1])
x[0] = result
```
В первой строчке вызовется мутация, а во второй уже будет запрещенное присваивание. Но почему же мы можем представить `+=` в виде двух операций?

```python
>>> import dis
>>> def add():
...     x[0] += [1]
... 
>>> dis.dis(add)
             ...
             34 BINARY_OP               13 (+=)
             ...
             42 STORE_SUBSCR
             46 LOAD_CONST               0 (None)
             48 RETURN_VALUE

```
Внутри байткода увидим две операции: `BINARY_OP` и `STORE_SUBSCR`. `BINARY_OP` вызовет магический метод `__iadd__`, а `STORE_SUBSR` пытается переприсвоить значение `x[0]`. Ровно поэтому операция `+=` не атомарна.

### модуль operator

Модуль `operator` должен быть в арсенале каждого разработчика, потому что он предоставляет декларативные способы для написания простого кода.

```python
>>> import operator
>>> operator.add(2, 3)
5
>>> operator.__add__(2, 3)
5
```

Зачем это нужно, если можно просто написать `a + b`? Если вы пишете колбеки или вы используете функциональное программирование в целом или только такие методы как `map`, `reduce`, то могут понадобиться готовые функции. Конечно, можно определить лямбды, которые делают то же самое, однако это не так красиво и аккуратно, как методы `operator`. 

Также есть метод для конкатенации последовательностей:

```python
>>> operator.concat([1], [2])
[1, 2]
```

Полистать все методы можно в [файле](https://github.com/python/cpython/blob/main/Lib/operator.py).

Интересный факт: у многих модулей в питоне есть аналоги, которые начинаются с нижнего подчёркивания, например `_operator`. Это значит, что этот модуль написан на си. Он не предназначен для использования, однако он зачем-то нужен. Обычно причины две: во-первых, там могут быть какие-то ускорялки, а во-вторых там могут быть части, нуждающиеся в CAPI, которые невозможно написать на чистом питоне. В случае модуля `operator` - это ускорялки. Обычный модуль `operator` [делает импорт](https://github.com/python/cpython/blob/main/Lib/operator.py#L413) из `_operator`, и если импорт удаётся, то используется сишный вариант. А если импорт не удаётся, например вы используете PyPy, а не cpython, тогда используется питоновская реализация:

```python
# Lib/operator.py#L413

try:
    from _operator import *
except ImportError:
    pass
else:
    from _operator import __doc__
```

Можно удостовериться, что _operator.add делает сложение на си:

```c
// Modules/_operator.c#L54C1

/*[clinic input]
_operator.add

    a: object
    b: object
    /

Same as a + b.
[clinic start generated code]*/

static PyObject *
_operator_add_impl(PyObject *module, PyObject *a, PyObject *b)
/*[clinic end generated code: output=8292984204f45164 input=5efe3bff856ac215]*/
{
    return PyNumber_Add(a, b);
}
```

Действительно, она принимает два объекта и делает вызов метода CAPI для сложения.
